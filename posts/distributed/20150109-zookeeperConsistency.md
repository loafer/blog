Zookeeper —— 一致性保证
==

Zookeeper是一个高性能，可扩展的服务。读和写被设计的很快，读的速度比写更快些。原因在于读的时候，Zookeeper能够提供旧数据。这都归结与Zookeeper的一致性保证：

** 顺序一致性 **
来自客户端的更新是按照发送顺序执行的

**原子操作**
更新要么成功，要么失败。没有中间结果。

**单一系统镜像**
无论客户端连接到哪个服务器，看到的服务场景都是一样的。

**可靠性**
一旦更新完成，状态就一直保持，直到客户端覆盖这个更新。这保证了两个推论：
>1.如果客户端成功获得返回吗，则表示更新已成完成。在某些故障情况下（通讯错误，超时，等）客户端不知道更新成功还是失败。我们采取措施减少失败，但成功返回码是唯一保证。

>2.客户端看到的任何更新，不会因为服务失败恢复而回滚。

**时效性**
客户端看到的视图，保证在一定时间内是最新的（数十秒）。在这期间客户端能看到系统变化，或者察觉出服务宕机。


使用这些一致性保证，在客户端就可以很容易的建立更高级的功能，如：leader选举、barriers、队列、读/写锁。

>有时候开发人员会错误的认为有另外一个保证，其实Zookeeper不提供，它就是：
**不同的客户端看到相同的场景**

>Zookeeper不会保证不同客户端在同一时间点上，看到相同的Zookeeper数据。由于网络延时的原因，会出现一个客户端应该在另一个客户端得到变更通知前更新数据。假设，有两个客户端A和B。如果A将节点/a的值由0变更为1，然后B读取/a节点，B可能读到旧的数据0。这取决与B连接的服务器。如果读取同一个值对A和B很重要，那么B应该在读之前调用**sync()**方法。

>尽管Zookeeper并不保证变化同步发生在所有服务器上，但是它还是能为客户端同步调用提供更高层的功能。