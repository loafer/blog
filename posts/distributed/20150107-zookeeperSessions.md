Zookeeper —— 会话
==

Zookeeper客户端通过创建一个handle去建立与Zookeeper集群的会话。handle一旦建立，就处于CONNECTION状态。然后客户端会尝试去连接Zookeeper集群中的某一台机器，直到handle状态变为CONNECTED。正常情况下，就是这两种状态之一。如果发生不可恢复的错误（如session超时、验证失败、服务关闭），handle将变为CLOSED状态。下图显示了Zookeeper客户端可能的状态转移：

![state](http://zookeeper.apache.org/doc/r3.4.6/images/state_dia.jpg)


要创建一个客户端会话，应用程序代码必须提供一个连接字符串，这个字符串是一个包含逗号分割的host:port对（例如："127.0.0.1:4545"或"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002"）。客户端会选取其中的任意一个去尝试连接。如果连接失败，或者因为server的原因连接断开，则客户端则自动再选一个尝试连接，直到与Zookeeper集群的连接被创建（或恢复）。

**3.2.0新增内容：**连接串后面可以添加一个可选后缀。这使得客户端命令解析的所有路径都是相对于这个根开始的（类似于Unix下的chroot命令）。如果使用下面的例子“127.0.0.1:4545/app/a“或者"127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a"，则表示客户端以"/app/a"为根，所有路径都是相对于这个根。也就是说针对”/foo/bar“的取数，实际是发生在"/app/a/foo/bar"处。这个特性在多租户环境下非常有用，一个特定的Zookeepr服务下每个用户可以有不同的根，这样使得每个用户在编码时只需要从"/"来考虑。在程序发布后会被固定到真实的位置。

当客户端从Zookeeper服务获得了一个handle时，Zookeeper就创建了会话，它以64位整数表示，并将它赋给了这个客户端。如果这个客户端连接到一个不同的Zookepper服务时，它需要将这个session id 作为连接握手的一部分。为了安全，服务器可以为这个session id创建一个密码，任何一台Zookeeper服务都可以去验证。在会话建立时，这个密码随session id发送个客户端。无论何时，客户端在一个新的服务器上恢复会话时，都需要将这个密码随session id一起发送给服务器。

客户端在创建会话时，可以通过参数指定会话超时（毫秒）。客户端发送一个要求的超时时间，服务端响应这个时间并发给客户端。目前这个超时时间最小为2倍的tickTime，最大为20倍的tickTime。Zookeeper客户端API允许协商这个超时时间。

当客户端从Zookeeper集群中断开时，它将开始搜索指定服务列表。当客户端与某台机器重新建立连接后，会话将再次变为”connected“状态（在超时时间内）或者变为”expired“状态（在会话超时后连接）。断开后再创建一个新的会话是不明知的，ZK客户端会帮你重建连接。需要特别注意，我们的客户端已经有处理类似”herd effect“这种问题的能力。你仅在被通知会话过期时才创建新的会话。

Zookeeper集群自己管理会话有效期，与客户端无关。当ZK客户端通过集群创建会话时，需要提供一个timeout值。集群通过这个值判断客户端会话是否超时。当失效发生时，表示集群在指定的timeout内没有收到来自客户端的消息（如心跳信息）。会话失效时集群将删除所有与该会话有关的临时节点，并立刻通知所有关注这些被删节点的在线客户端（在节点上设置watch的客户端）。这时，如果会话过期的客户端仍没有连接到集群，它不会被通知到已过期，直到它再次连接，才通知它会话已过期。客户端保持断开状态，直到与集群的TCP连接再次建立，这时，过期的会话的监视器（Wather）将接收到”会话过期“的通知。

通过过期会话的监视器来看过期会话的状态变化：

1	'connected'：会话已建立，客户端可以与集群通讯。
2	..... 客户端与集群断开
3	'disconnected'：客户端已经与集群失去了连接
4	......过了一段时间，已超过timeout时间，集群将会话过期，客户端不会知道，应为它已与集群断开
5	......又过了一段时间，客户端与集群再次连接。
6	'expired'：最终客户端连接上了集群，它被通知已过期。


创建会话的另一个参数是默认的watcher。客户端任何状态的变化都会通知watcher。例如，客户端与服务器失去连接，它会被通知，或者客户端会话过期等。watcher认为初始状态是断开的（任何事件发生前，客户端库都将会通知watcher）。在新建连接中，发送给watcher的第一个事件是会话连接事件。

客户端通过发送请求保持会话。客户端是通过发送PING请求来保持会话的。这个PING请求不仅是让Zookeeper服务知道客户端还在线，而且也是为了让客户端知道它连接的Zookeeper服务还在工作。PING时间应确保合理，以便能发现一个死连接和重连一个新的服务。

一旦与服务建立连接，在执行同步或异步操作时，有两种情况可以使客户端库与服务失去连接：

- 应用在一个失效很长时间的会话上调用一个操作
- 在被连接的Zookeeper服务上存在一个还未完成的操作。如：未完成的异步调用。

**3.2.0新增内容：**SessionMovedException是一个内部异常，通常客户端看不到。这个异常产生的原因通常是因为客户端发送了一个请求，由于网络延时，客户端在另一个服务上恢复了连接，但是之前那个请求又被之前的那个旧的服务器收到，旧的服务器发现会话已经被转移了，于是它就关闭了客户端的连接。客户端通常不会看到这个错误，因为它不会从旧服务上读数据（旧连接已经被关闭）。当两个客户端试图使用相同的session ID和密码再去建立这个会话时，则会看到这个错误。这会造成一个再次建立了会话，而另一个又断开了（至于那个建立，哪个断开，这个不确定）。

