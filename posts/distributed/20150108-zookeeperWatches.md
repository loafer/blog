Zookeeper —— Watches
==

在Zookeeper中的所有读操作——getData(), getChildren(), exists() 都可以添加一个监视器，作为附带的功能。Zookeeper的监视器定义如下：监视事件是个一次性触发事件，它被发送到设置它的客户端，触发条件为设置有监视器的数据发生改变时。在定义监视器时需要考虑3个关键点：

- **一次性触发**
当数据发生了变更，监视器事件被发送给客户端。例如，如果客户端执行该方法getData('/znode1', true)并且稍后/znode1上的数据发生了改变或删除，客户端将获得一个关于/znode1的监视器事件。如果/znode1又发生了改变，则不会有监视器事件除非客户端再次执行读操作时又设置了一个新的监视器。

- **发送给客户端**
事件一定在数据变更成功后被发送，即发出数据变更的客户端收到了变更成功的消息。事件是异步发送给的。这些对于那些设置监视器的客户端来说是看不到的，它只会得到监视事件。网络延时或其他原因可能引起不同的客户端在收到监视事件和结果时会有时间先后。但是不同客户端所看到的一切都有一致的顺序。

- **被监视器监视的数据**
一个节点不同方式的变更，有助于你理解Zookeeper维护的两个监视列表：数据监视器和子节点监视器。getData()和exists()设置数据监视器，getChildren()设置子节点监视器。当然，你也可以通过这些方法的返回值类型来理解监视器。getData()，exists()返回节点数据，getChildren()返回一组子节点。因此，setData()将触发数据监视器事件，create()（架设成功）将触发被建节点的数据监视器和其父节点的子节点监视器。delete()会触发被删节点的数据监视器和子节点监视器（），以及被删节点父节点的子节点监视器。

监视器在客户端所连接的服务器上维护。这使得监视器可以方便的设置、维护和分发。当客户端连接到一个新的服务器上时，监视器将被任意会话事件所触发。没连接到服务器的客户端不会收到监视事件。但是，当它再次连接上时，之前注册的监视器将被再注册和触发（如果需要的话），通常这一切都是透明的。但有一种情况监视器会丢失：为还未创建的节点设置监视器，当断开连接后，如果节点被创建和删除，则不会得到监视器。

对于监视器，Zookeeper能做到以下保证：

- 与其他事件，其他监视器，其他应答一样，监视器也是有顺序的。Zookeeper客户端库能保证所有事情都能按照顺序依次分发。
- 客户端先看到监视器事件，然后是数据。
- 监视器事件的顺序就是Zookeper服务看到的更新顺序。

###关于监视器，你应该注意什么
- 监视器是一个一次性触发器。如果你已经得到了一个监视器事件，还在想得到下一次的监视器事件，你需要重新设置一个监视器。

- 由于监视器是一个一次性触发器。在得到一个事件和发送一个新监视器之间存在延时，所以不能保证会看到发生在节点上的每次变更。因此要注意，在得到事件和再次设置新监视器这段时间内节点已经发生了多次变更（你可能不在乎，但至少要意识到它会发生）。

- 一个监视器对象（或者是方法/上下文对）对于特定的通知仅会触发一次。如果同一个监视器对象在调用exists()和getData()方法时被注册到了同一个文件上，随后文件被删除。则这个监视器对象仅在文件删除通知时被触发。

- 当你从一个服务器上断开后，你将无法得到任何监视器，除非连接被恢复。这是由于会话事件被发送给了所有未完成的监视器。使用会话事件进入安全模式：掉线期间你将无法收到事件，因此你的过程应该采取保守的模式